[{"content":"","date":"2025-05-22T17:38:22+08:00","permalink":"https://Xinen-hardwork.github.io/hugo-dev/zh-cn/p/selenium%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"Selenium基础知识"},{"content":"1 发起 HTTP 请求 发起 HTTP 请求的过程一般是先在浏览器中输入 URL，浏览器将网络请求发送给服务器，由服务器解析返回结果\n1.1 HTTP 请求原理 HTTP 请求是在客户端和 Web 服务器之间的交互请求，需要进行多次请求与确认\n（1）客户端连接到 Web 服务器，HTTP 客户端与 Web 服务器的 HTTP 端口（8080）建立一个 TCP套接字\n（2）发送 HTTP 请求，客户端通过 TCP 套接字向 Web 服务器发送一个文本请求报文（请求行、头、空行、体）\n（3）服务器接收请求并返回 HTTP 响应，Web 服务器解析请求，定位请求资源，客户端读取服务器写入 TCP 套接字的资源副本\n（4）释放 TCP 连接，若 connection 为 close 服务器主动 关闭 TCP 连接，客户端被动关闭连接，释放 TCP；connection 为 keepalive 连接会保持一段时间，该时间内可继续接收请求\n（5）客户端浏览器解析 HTML 内容\nTCP/IP 中三次握手建立一个可靠的连接服务\n（1）第一次握手，建立连接时客户端发送 SYN 包（SYN=1）到服务器进入 SYN_SENT 状态，等待服务器确认，SYN 为同步序列编号\n（2）第二次握手，服务器收到 SYN 包，确认客户的 SYN（ack=J+1）,ack是确认号，ACK为确认标识，同时自己也发送一个 SYN 包，服务器进入 SYN_RCVD 状态\n（3）第三次握手，客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 (ack=K+1) ，客户端和服务器都进入 ESTABLISHED 状态\n1.2 Python 发起 HTTP 请求 自动化测试一般不会直接使用浏览器访问网页，而是使用工具或者程序脚本实现，python 使用类库发起一个 HTTP 请求非常容易。\n1. 使用 requests（基本封装了 urllib 库所有功能） 使用 requests 发起一个 HTTP 请求的实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #-*-coding:utf-8-*- import requests\t# 导入requests 库 # 使用 GET 方式请求个人网站 （得开梯子） response = requests.get(\u0026#34;https://xinen-hardwork.github.io/hugo-dev/zh-cn/\u0026#34;) # 打印响应结果 print(response) # 查看响应内容 # response.text 为 Unicode 格式的数据 print(response.text) # response.content 为 字节流数据 print(response.content) # 查看完整的 URL print(response.url) # 查看响应头部编码 print(response.encoding) # 查看响应码 print(response.status_code) 运行结果：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;Response [200]\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-cn\u0026#34; dir=\u0026#34;ltr\u0026#34;\u0026gt; ... \u0026lt;/html\u0026gt; b\u0026#39;\u0026lt;!DOCTYPE html\u0026gt;\\n\u0026lt;html lang=\u0026#34;zh-cn\u0026#34; dir=\u0026#34;ltr\u0026#34;\u0026gt;\\n ... \u0026lt;/script\u0026gt;\\n\\n \u0026lt;/body\u0026gt;\\n\u0026lt;/html\u0026gt;\\n\u0026#39; https://xinen-hardwork.github.io/hugo-dev/zh-cn/ utf-8 200 后续编写复杂功能代码时需要利用 status code 属性合理判断，并处理好 response.txt 中的文本内容\n2. 使用 urllib urllib 是 python 内置的 HTTP 请求类库，可直接使用，包含 4 个模块\n模块 描述 request 模拟发送请求 error 出现错误捕获异常 parse 对 URL 拆分解析 robotparser 识别网站的 robots.txt 文件，判断哪些文件会被爬虫处理 使用 urllib 的一个实现\n1 2 3 4 5 import urllib.request # 获取一个 HTTP 响应对象 response = urllib.request.urlopen(\u0026#34;https://xinen-hardwork.github.io/hugo-dev/zh-cn/\u0026#34;) print(response) 运行结果\n1 \u0026lt;http.client.HTTPResponse object at 0x00000289A1538A90\u0026gt; urllib 使用较复杂，传入参数也更多，建议使用 requests 包发起 HTTP 请求\n3. python 处理响应对象 获取响应对象后先判断状态码，对 text 属性设置编码，最后获取所需的文本，实现如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import requests\t# 导入requests 库 # 使用 GET 方式请求个人网站 （得开梯子） response = requests.get(\u0026#34;https://xinen-hardwork.github.io/hugo-dev/zh-cn/\u0026#34;) # 2. 检查状态码（确保请求成功） if response.status_code == 200: # 3. 设置响应文本编码（优先使用响应头声明的编码） response.encoding = response.apparent_encoding # 自动推断编码 # 或手动指定编码（如已知编码）： response.encoding = \u0026#39;utf-8\u0026#39; # 4. 获取文本内容 content = response.text print(\u0026#34;响应内容：\u0026#34;, content[:100]) # 打印前100字符避免刷屏 else: print(f\u0026#34;请求失败，状态码：{response.status_code}\u0026#34;) 运行结果\n1 2 3 4 响应内容： \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-cn\u0026#34; dir=\u0026#34;ltr\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta name=\u0026#34;generator\u0026#34; content=\u0026#34;Hugo 0.147 2 HTTP HTTP（超文本传输协议）是一个 TCP/IP 应用层的协议，由请求和响应构成，是一个标准的客户端/服务器模型。HTTP 是一个无状态的协议，默认使用 80 端口，HTTPS 默认使用443端口。请求头部信息包含如下重要参数\n参数 描述 Method 请求方式，GET、POST、DELETE、PUT和PATCH等 Accept-Encoding 编码方式，一把默认开启压缩，如 gzip Accept-Language 支持语言 Cookie 存储用户访问信息的账本，浏览器自带 User-Agent 客户端信息 2.1 HTTP 状态码 HTTP 状态码（HTTP Status Code）表示网页服务器超文本传输协议响应状态的 3 位数字代码，代表请求的服务端的状态\n常见的状态码：\n状态码 描述 200 OK 请求已被服务器成功接收、理解、接受 201 Created 请求已被实现，新的资源已经依据请求的需要而建立，其 URL 已随 Location 头信息返回 301 Moved Permanently 被请求的资源已永久的移动到新位置，将来任何此资源的引用都使用本响应返回的若干个 URL 之一 304 Not Modified 禁止包含消息体 请求错误情况下返回的状态码 （4XX）\n状态码 描述 400 Bad Request 语义有误，当前请求无法被服务器理解 401 Unauthorized 当前请求需要用户验证 403 Forbidden 服务器已经理解请求，但是拒绝执行 404 Not Found 请求失败，希望得到的资源未在服务器上发现 405 Method Not Allowed 请求行中指定的请求方法不能被用于请求相应的资源 408 Request Timeout 请求超时，客户端没有在服务端预备等待的时间内完成一个请求的发送 451 Unavailable For Legal Reasons 该请求因为法律原因不可用 服务端抛出的错误（5XX）\n状态码 描述 500 Internal Server Error 服务器遇到一个未曾预料到的状况导致它无法完成对请求的处理 501 Not Implemented 服务器不支持当前请求所需要的某个功能 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应 503 Service Unavailable 临时的服务器维护或者过载，服务器当前无法处理请求 504 Gateway Timeout 作为网关或者代理工作的服务器尝试执行请起请求时，未能及时从上游服务器或者辅助服务器收到响应 Python 处理 code 就是用响应对象的 status_code 属性和状态码进行比较，对不同的状态码用对应的逻辑处理即可，实例如下\n1 2 3 4 5 6 7 8 9 10 import requests response = requests.get(\u0026#34;https://xinen-hardwork.github.io/hugo-dev/zh-cn/\u0026#34;) if response.status_code == 200: print(\u0026#34;request is ok\u0026#34;) elif response.status_code == 404: print(\u0026#34;the page is not found\u0026#34;) elif response.status_code \u0026gt;= 500: print(\u0026#34;Server has something wrong\u0026#34;) 运行结果\n1 request is ok 2.2 Python 处理业务码 业务码，用于描述业务状态的编码，常规操作包含如下几个操作\n① 判断业务码，根据不同业务进行分支和逻辑判断\n② 断言判断，业务码判断成功就进入该流程（根据断言判断是否符合预期）\n③ 错误处理，业务码判断失效就进入错误处理，进行相关错误信息的记录，或抛出错误信息等操作\n④ 持久化存储结果，包含错误信息和断言信息，可选择 MySQL 作为持久化存储的数据库\n⑤ 输出结果报表，将结果导出为电子表格或者文本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import time import requests def deal(str code) : switchar = { \u0026#34;40001\u0026#34;:\u0026#34;param is invalid\u0026#34;, \u0026#34;40002\u0026#34;:\u0026#34;param lost verify part\u0026#34;, \u0026#34;40003\u0026#34;:\u0026#34;not permission param\u0026#34;, } msg = switchar.get(code, \u0026#34;ok\u0026#34;) if msg != ok: with open(\u0026#39;error.txt\u0026#39;, \u0026#39;w\u0026#39;) as f :\t# 设置文件对象 data_str = time.strftime(\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;, time.localtime()) f.write(data_str + msg) else: # 业务码正确，说明逻辑正确，进行正常的处理流程 print(\u0026#34;success!!!\u0026#34;) response = requests.get(\u0026#34;https://xinen-hardwork.github.io/hugo-dev/zh-cn/\u0026#34;) json_data = response.text.json() deal(json_data.code) 运行结果\n1 \u0026#34;JSON解析失败: Expecting value: line 1 column 1 (char 0)\u0026#34; 3 GET 和 POST 请求 3.1 HTTP 请求方式 HTTP 请求可使用多种请求方式\nHTTP 1.0 中定义 3 种请求方式：GET、POST、HEAD\nHTTP 1.1 新增 6 种请求方式：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT\n根据复杂程度，请求可分为：\n简单请求，HTTP 1.0 中 3 中请求方法（HEAD、GET 和 POST） 没有自定义的报头，类型为 MIME Type in text/plain、multipart/form-data、application/x-www-form-urlencoded 3.2 Python 发起 GET 请求 1 带参数的请求 使用字典形式传递参数，网页采用 gzip 压缩时读取 text 属性可能会出现乱码，建议使用 content 属性，实例：\n1 2 3 4 5 6 7 8 9 10 import requests \u0026#39;\u0026#39;\u0026#39; 最终拼接效果为： https://www.baidu.com/?wd=python \u0026#39;\u0026#39;\u0026#39; param = {\u0026#34;wd\u0026#34;:\u0026#34;python\u0026#34;} get_url = \u0026#39;https://www.baidu.com\u0026#39; response = requests.get(get_url, params=param) print(response) print(response.content) 运行结果\n1 2 3 4 \u0026lt;Response [200]\u0026gt; b\u0026#39;\u0026lt;!DOCTYPE html\u0026gt;\\r\\n\u0026lt;!--STATUS OK--\u0026gt;\u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;meta http-equiv=content-type ... \\xb7\u0026amp;nbsp; \u0026lt;img src=//www.bai(auto_test) PS D:\\Coding\\pythonProjects\u0026gt; \u0026amp; d:/Coding/pythonProjects/ 2 携带 Session 参数 保持登陆状态或者用户状态可在发起请求时传递 cookie 参数，该会话对象在同一个 Session 实例发出的所有请求之间保存 cookie信息\n1 2 3 4 5 6 7 8 import requests s = requests.Session() r = s.get(\u0026#39;http://httpbin.org/cookies\u0026#39;, cookies={\u0026#39;from-my\u0026#39;:\u0026#39;browser\u0026#39;}) print(r.text) r = s.get(\u0026#39;http://httpbin.org/cookies\u0026#39;) print(r.text) 运行结果\n1 2 3 4 5 6 7 8 { \u0026#34;cookies\u0026#34;: { \u0026#34;from-my\u0026#34;: \u0026#34;browser\u0026#34; } } { \u0026#34;cookies\u0026#34;: {} } 3 请求 Prepared Request 发送请求之前还需要一些个性化设置，可传入 header 参数，实例\n1 2 3 4 5 6 7 8 9 10 from requests import Request, Session s = Session() url = \u0026#39;https://www.cnblogs.com\u0026#39; data = {\u0026#34;s\u0026#34;:\u0026#34;Golang\u0026#34;} header = {\u0026#39;Accept-Encoding\u0026#39;:\u0026#39;identity, deflate, compress, gzip\u0026#39;, \u0026#39;Accept\u0026#39;:\u0026#39;*/*\u0026#39;, \u0026#39;User-Agent\u0026#39;:\u0026#39;python-requests/0.13.1\u0026#39;} req = Request(\u0026#39;GET\u0026#39;, url, data=data, headers=header) prepare_opj = req.prepare() resp = s.send(prepare_opj, timeout=10) print(resp.status_code) 运行结果\n1 200 4 SSL 支持 SSL 是 HTTPS 的证书服务，requests 库可以在发起请求时携带 SSL 证书，默认SSL 验证是开启的\n1 requests.get(\u0026#39;https://github.com\u0026#39;, verify = \u0026#39;/path/to/certfile\u0026#39;) 5 设置代理 代理设置实例\n1 2 3 4 5 6 import requests proxies = { \u0026#34;http\u0026#34; : \u0026#34;http://10.10.1.10:3128\u0026#34;, \u0026#34;https\u0026#34; : \u0026#34;https://10.10.1.10:1080\u0026#34;, } requests.get(\u0026#34;http://example.org\u0026#34;, proxies=proxies) 3.3 Python 发起 POST 请求 POST 提交的数据放在消息主体（entity-body），编码一般使用 application/x-www-form-urlencoded、multipart/form-data 或 raw\npython 中也可自己用字典构造参数，使用 post() 函数即可\n1 requests.post(url, post_data) 第一个参数为请求的 URL，第二个参数为字典类型的提交数据\n1 常规用法 直接使用 post() 函数\n1 2 3 4 5 6 7 import requests url = \u0026#39;http://httpbin.org/post\u0026#39; data = {\u0026#39;key1\u0026#39;:\u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;:\u0026#39;value2\u0026#39;} r = requests.post(url, data) print(r) print(r.text) print(r.content) 运行结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;Response [200]\u0026gt; { \u0026#34;args\u0026#34;: {}, \u0026#34;data\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;files\u0026#34;: {}, \u0026#34;form\u0026#34;: { \u0026#34;key1\u0026#34;: \u0026#34;value1\u0026#34;, \u0026#34;key2\u0026#34;: \u0026#34;value2\u0026#34; }, \u0026#34;headers\u0026#34;: { \u0026#34;Accept\u0026#34;: \u0026#34;*/*\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;*/*\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate\u0026#34;, \u0026#34;Content-Length\u0026#34;: \u0026#34;23\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, \u0026#34;Host\u0026#34;: \u0026#34;httpbin.org\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;python-requests/2.32.3\u0026#34;, \u0026#34;X-Amzn-Trace-Id\u0026#34;: \u0026#34;Root=1-682ee72d-512b90640e139ab831ea9e60\u0026#34; }, \u0026#34;json\u0026#34;: null, \u0026#34;origin\u0026#34;: \u0026#34;1.36.244.149\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://httpbin.org/post\u0026#34; } b\u0026#39;{\\n \u0026#34;args\u0026#34;: {}, \\n \u0026#34;data\u0026#34;: \u0026#34;\u0026#34;, \\n \u0026#34;files\u0026#34;: {}, \\n \u0026#34;form\u0026#34;: {\\n \u0026#34;key1\u0026#34;: \u0026#34;value1\u0026#34;, \\n \u0026#34;key2\u0026#34;: \u0026#34;value2\u0026#34;\\n }, \\n \u0026#34;headers\u0026#34;: {\\n \u0026#34;Accept\u0026#34;: \u0026#34;*/*\u0026#34;, \\n \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate\u0026#34;, \\n \u0026#34;Content-Length\u0026#34;: \u0026#34;23\u0026#34;, \\n \u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, \\n \u0026#34;Host\u0026#34;: \u0026#34;httpbin.org\u0026#34;, \\n \u0026#34;User-Agent\u0026#34;: \u0026#34;python-requests/2.32.3\u0026#34;, \\n \u0026#34;X-Amzn-Trace-Id\u0026#34;: \u0026#34;Root=1-682ee72d-512b90640e139ab831ea9e60\u0026#34;\\n }, \\n \u0026#34;json\u0026#34;: null, \\n \u0026#34;origin\u0026#34;: \u0026#34;1.36.244.149\u0026#34;, \\n \u0026#34;url\u0026#34;: \u0026#34;http://httpbin.org/post\u0026#34;\\n}\\n\u0026#39; 2 JSON 形式 使用 JSON 形式的实例\n1 2 3 4 5 6 7 8 import requests, json url_json = \u0026#39;http://httpbin.org/post\u0026#39; # dumps: 可以将 Python 对象解码为 JSON 对象 data_json = json.dumps({\u0026#39;stock_no\u0026#39;:\u0026#39;600585\u0026#39;, \u0026#39;price\u0026#39;:\u0026#39;52.12\u0026#39;}) res = requests.post(url_json,data_json) print(res) print(res.text) print(res.content) 运行结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;Response [200]\u0026gt; { \u0026#34;args\u0026#34;: {}, \u0026#34;data\u0026#34;: \u0026#34;{\\\u0026#34;stock_no\\\u0026#34;: \\\u0026#34;600585\\\u0026#34;, \\\u0026#34;price\\\u0026#34;: \\\u0026#34;52.12\\\u0026#34;}\u0026#34;, \u0026#34;files\u0026#34;: {}, \u0026#34;form\u0026#34;: {}, \u0026#34;headers\u0026#34;: { \u0026#34;Accept\u0026#34;: \u0026#34;*/*\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate\u0026#34;, \u0026#34;Content-Length\u0026#34;: \u0026#34;40\u0026#34;, \u0026#34;Host\u0026#34;: \u0026#34;httpbin.org\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;python-requests/2.32.3\u0026#34;, \u0026#34;X-Amzn-Trace-Id\u0026#34;: \u0026#34;Root=1-682ee8e4-15c5a31e4fc5ddd87bbda665\u0026#34; }, \u0026#34;json\u0026#34;: { \u0026#34;price\u0026#34;: \u0026#34;52.12\u0026#34;, \u0026#34;stock_no\u0026#34;: \u0026#34;600585\u0026#34; }, \u0026#34;origin\u0026#34;: \u0026#34;1.36.244.149\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://httpbin.org/post\u0026#34; } b\u0026#39;{\\n \u0026#34;args\u0026#34;: {}, \\n \u0026#34;data\u0026#34;: \u0026#34;{\\\\\u0026#34;stock_no\\\\\u0026#34;: \\\\\u0026#34;600585\\\\\u0026#34;, \\\\\u0026#34;price\\\\\u0026#34;: \\\\\u0026#34;52.12\\\\\u0026#34;}\u0026#34;, \\n \u0026#34;files\u0026#34;: {}, \\n \u0026#34;form\u0026#34;: {}, \\n \u0026#34;headers\u0026#34;: {\\n \u0026#34;Accept\u0026#34;: \u0026#34;*/*\u0026#34;, \\n \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate\u0026#34;, \\n \u0026#34;Content-Length\u0026#34;: \u0026#34;40\u0026#34;, \\n \u0026#34;Host\u0026#34;: \u0026#34;httpbin.org\u0026#34;, \\n \u0026#34;User-Agent\u0026#34;: \u0026#34;python-requests/2.32.3\u0026#34;, \\n \u0026#34;X-Amzn-Trace-Id\u0026#34;: \u0026#34;Root=1-682ee8e4-15c5a31e4fc5ddd87bbda665\u0026#34;\\n }, \\n \u0026#34;json\u0026#34;: {\\n \u0026#34;price\u0026#34;: \u0026#34;52.12\u0026#34;, \\n \u0026#34;stock_no\u0026#34;: \u0026#34;600585\u0026#34;\\n }, \\n \u0026#34;origin\u0026#34;: \u0026#34;1.36.244.149\u0026#34;, \\n \u0026#34;url\u0026#34;: \u0026#34;http://httpbin.org/post\u0026#34;\\n}\\n\u0026#39; 3 文件流形式 以 multipart 形式发送 POST 请求，实现\n1 2 3 4 5 6 7 import requests, json url_mul = \u0026#39;http://httpbin.org/post\u0026#39; files = {\u0026#39;file\u0026#39;:open(\u0026#39;./report.txt\u0026#39;, \u0026#39;rb\u0026#39;)} res = requests.post(url_mul,files=files) print(res) print(res.text) print(res.content) 3.4 Python 实现自动登陆实例 实现思路：\n① 使用浏览器模拟库获取页面元素\n② 填写账号密码\n③ 提交数据，完成登录\nsplinter ，是一个 Web 应用测试工具，实现自动浏览站点并进行交互，封装了对浏览器的操作，形成了一个上层应用 API\n登录 postman 的实例操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import time from splinter import Browser def login_postman(url) : browser = Browser() browser.visit(url) browser.find_by_id(\u0026#39;username\u0026#39;).fill(\u0026#39;用户名\u0026#39;) browser.find_by_id(\u0026#39;password\u0026#39;).fill(\u0026#39;密码\u0026#39;) browser.find_by_id(\u0026#39;loginBtn\u0026#39;).click() print(\u0026#39;登陆成功\u0026#39;) time.sleep(3) print(\u0026#39;退出登录\u0026#39;) browser.quit() if __name__ == \u0026#39;__main__\u0026#39; : main_addr = \u0026#39;https://identity.getpostman.com/signup\u0026#39; login_postman(main_addr) ","date":"2025-05-21T20:17:40+08:00","permalink":"https://Xinen-hardwork.github.io/hugo-dev/zh-cn/p/python-http-%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/","title":"Python HTTP 接口编程"},{"content":"1 测试方式分类 根据测试内容划，可划分为 4 类\n分类 描述 功能性测试 测试软件功能是否如预期一样正常，包含兼容性测试 性能测试 对系各项性能指标进行测试，如页面响应速度和渲染速度等 特性测试 测试不同平台的差异，如 PC 和移动端的兼容性差异 安全测试 测试数据传输和存储的安全性及访问资源的权限 RAD (Rap Application Development, 快速应用开发) 又称 V 模型，RAD 模型大体可以划分为下图的阶段\n根据测试级别，划分为 5 类\n分类 描述 单元测试 对单一接口或单元级别功能进行测试 集成测试 迭代过程中每次集成后进行的测试，保证每次小幅迭代的功能点都能被测试并通过验证 接口测试 对系统接口的测试，可使用 Mock 数据做冒烟测试 系统测试 根据系统设计书的指导对系统的功能点进行测试，发现软件潜在问题，保证系统正常运行 验收测试 根据功能说明书的功能点进行测试，保证产品顺利交付给用户（客户） W 模型增加了软件开发各阶段中同步进行的验证和确认活动\n2 自动化测试 自动化测试，将人工测试中重复的测试步骤实现机器化、代码化，避免人工操作与结果比较，并利用工具进行全面、可反复的测试回溯的方法\n“ 三层金字塔” 的分层自动化测试模型\n分层 实践 UI 层 人工测试及用户界面的自动化测试 Service 层 通过自动化框架或工具进行接口测试 Unit 层 基于最小模块进行单元测试 3 Python自动化测试 单元测试框架，Java 的 JUnit 和 TestNG，PHP 的 PHPUnit, Python 的 unittest 和 pytest等\nPython 适合做自动化测试的优势：\n① Python 自动化测试脚本编写简单方便\n② 有成熟的自动化框架（Selenium 等）\n③ 丰富的类库支持（HTTP网络请求、文件流处理、Socket编程、多线程等）\nPython 自动化测试实际应用\n4 接口测试和UI测试 接口测试，对某个服务的函数或者对外暴露的访问接口进行测试，测试的目的是检测该接口是否稳定可靠以及是否符合预设的用例测试结构。一般分为下面3种：\n基于 HTTP 接口测试\n基于 Web 服务的接口测试\n基于其他通信协议的接口测试（Websocket 等）\nUI 测试，基于用户界面进行测试，需要针对页面的特定内容和功能进行。根据平台不同，可分为 Web 端 UI 测试和移动端 UI 测试\nWeb 端 UI测试\n① Web 整体页面测试\n② Web 内容测试\n③ Web 导航测试\n④ Web 图形测试\n⑤ Web 表单测试\n⑥ Web 兼容性测试（多平台兼容行）\n移动端 UI 测试\n① 基础功能测试，注意边界值、异常数据等。分析需求和功能要求，对流程梳理，以跑通基础功能为主\n② 数据交互测试，对页面上的数据流进行测试（也要测边界和特殊值）\n③ 性能测试，页面响应速度、资源加载、流量消耗、CPU占有率、电量的变化及APP稳定性的测试\n接口测试和 UI 测试的差异对比\n对比项 接口测试 UI测试 涉及页面 NO YES 需要跨平台测试 NO YES 复杂度 LOW HIGH 性能要求 MIDDLE HIGH ","date":"2025-05-21T15:27:03+08:00","permalink":"https://Xinen-hardwork.github.io/hugo-dev/zh-cn/p/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/","title":"自动化测试基础"}]